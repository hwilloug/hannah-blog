import SyntaxHighlighter from "react-syntax-highlighter";
import ClickableFullSizeImage from "../components/ClickableFullSizeImage";
import {
  ArticleContentContainer,
  Code,
  Section,
  SectionHeader,
  SubsectionHeader,
} from "../components/StyledComponents";

const migrationCode = `"""Add likes to article table

Revision ID: 5b2423dc9d5c
Revises: 239d28898a5f
Create Date: 2024-04-07 14:26:20.671103

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '5b2423dc9d5c'
down_revision: Union[str, None] = '239d28898a5f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('articles', sa.Column('likes', sa.Integer(), nullable=False, server_default=str(0)))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('articles', 'likes')
    # ### end Alembic commands ###
`;

const lambdaCode = `from os import environ
from psycopg2 import connect, DatabaseError
from psycopg2.extras import RealDictCursor
from sys import exit
from json import dumps, loads

username = environ.get("POSTGRES_USERNAME")
password = environ.get("POSTGRES_PASSWORD")
host = environ.get("POSTGRES_HOST")
port = environ.get("POSTGRES_PORT")
db_name = environ.get("POSTGRES_DB_NAME")

def lambda_handler(event, context):
    
    body = event.get("body", {})
    path_parmas = event.get("pathParameters", {})
    slug = path_parmas.get("slug")
    decrease = body.get("decrease", False)
    if slug is None:
        return {
            "statusCode": 400,
            "body": dumps({"message": "Slug is required in body"}),
            "headers": {
              'Access-Control-Allow-Origin' : '*'
            }
        }

    try:
        conn = connect(host=host, database=db_name, user=username, password=password, port=port)
    except DatabaseError as e:
        print("Could not connect to db", e)
        exit(1)

    sql = "SELECT likes FROM articles WHERE slug = %s"

    with conn.cursor(cursor_factory=RealDictCursor) as cursor:
        cursor.execute(sql, (slug,))
        results = cursor.fetchone()

    if results is None:
        return {
            "statusCode": 404,
            "body": dumps({"message": f"Could not find slug: {slug}"}),
            "headers": {
                'Access-Control-Allow-Origin' : '*'
            }
        }
    
    likes = results.get("likes")

    if decrease:
        new_likes = likes - 1
        if new_likes < 0:
            new_likes = 0
    else:
        new_likes = likes + 1

    update_sql = "UPDATE articles SET likes = %s WHERE slug = %s"

    with conn.cursor(cursor_factory=RealDictCursor) as cursor:
        cursor.execute(update_sql, (new_likes, slug))
        conn.commit()

    return {
        "statusCode": 200,
        "body": dumps({"likes": new_likes}, default=str),
        'headers' : {
            'Access-Control-Allow-Origin' : '*'
        }
    }
`;

const terraformCodeLambda = `module "like_article_lambda" {
  source = "../lambda"

  database_host     = var.database_host
  database_port     = var.database_port
  database_username = var.database_username
  database_password = var.database_password
  database_name     = var.database_name
  function_name     = "like_article"
  table_name        = "article"

  lambda_layer_arns = var.lambda_layer_arns
}
`;

const terraformCodeApiGateway = `resource "aws_apigatewayv2_integration" "like_article_lambda_integration" {
  api_id           = aws_apigatewayv2_api.api.id
  integration_type = "AWS_PROXY"

  connection_type      = "INTERNET"
  integration_method   = "POST"
  integration_uri      = module.like_article_lambda.invoke_arn
  passthrough_behavior = "WHEN_NO_MATCH"
}

resource "aws_apigatewayv2_route" "like_article_route" {
  api_id    = aws_apigatewayv2_api.api.id
  route_key = "POST /articles/{slug}/like"

  target = "integrations/\${aws_apigatewayv2_integration.like_article_lambda_integration.id}"
}

resource "aws_lambda_permission" "like_article_lambda_permission" {
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = module.like_article_lambda.function_name
  principal     = "apigateway.amazonaws.com"

  source_arn = "\${aws_apigatewayv2_api.api.execution_arn}/*"
}
`;

const reactCode1 = `const LikesContainer = styled("div")({
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  gap: "5px",
  margin: "10px"
})

interface LikesProps {
  slug: string
  likes: number
}

const Likes: React.FC<LikesProps> = ({ slug, likes }) => {
  const cookieName = 'hannahshobbyroom-likes'
  const [cookies, setCookie] = useCookies([cookieName])
  const theme = useTheme()

  const [liked, setLiked] = useState(false)
  const [numLikes, setNumLikes] = useState(likes)

  useMemo(() => {
    if (cookies[cookieName] && cookies[cookieName][slug]) {
      setLiked(true)
    }
  }, [cookies])

  const toggleLike = () => {
    const newValue = !liked
    try {
      axios.post(
        \`\${process.env.REACT_APP_API_URL}/articles/\${slug}/like\`,
        {
          "decrease": !newValue
        }
      )
      if (newValue) {
        setCookie(cookieName, {...cookies[cookieName], [slug]: true})
        setNumLikes(numLikes + 1)
      } else {
        let newCookies = {...cookies[cookieName]}
        delete newCookies[slug]
        setCookie(cookieName, newCookies)
        setNumLikes(numLikes - 1)
      }
    } catch (e) {
      console.log(e)
    }
    
    setLiked(newValue)
  }

  return (
    <LikesContainer onClick={toggleLike}>
      <ThumbUpAltIcon color={liked ? "secondary" : "primary" } /> {numLikes}
    </LikesContainer>
  )
}`;

const LikingArticles: React.FC = () => {
  return (
    <ArticleContentContainer>
      <Section>
        <SectionHeader>Liking Articles</SectionHeader>
        <p>
          You can now like my articles! Just click the thumbs up below the
          article information or at the bottom of the article to give the it a
          like ðŸ˜‰ You don't need to be logged in or anything, it just saves that
          you liked the article as a cookie.
        </p>
        <ClickableFullSizeImage
          src={`${process.env.REACT_APP_IMAGES_BASE_URL}/like_button.gif`}
        />
      </Section>
      <Section>
        <SectionHeader>Technical Considerations</SectionHeader>
        <p>
          Here are some things I either needed to figure out a good solution for
          or just didn't know design patterns for yet.
        </p>
        <ol>
          <li>
            How to store the likes in the database while:
            <ol style={{ listStyleType: "lower-alpha" }}>
              <li>
                Allowing anyone to like an article, even if they aren't logged
                in
              </li>
              <li>
                Preventing the same user from liking a post multiple times
              </li>
            </ol>
          </li>
          <li>
            How to prevent overwriting number of likes during high traffic
            periods
          </li>
        </ol>
        <p>
          ChatGPT recommended a few different approaches to the first question:
          a likes table that stores the likes for each post along with the IP
          address of the person who liked the post; or using cookies to keep
          track of which post a user has liked, along with a simple number of
          likes column on the articles table. I figured using cookies would be
          the most simple approach, as well as just better privacy-wise because
          it's not storing the IP addresses of my users. The cookies solution
          would also require some sort of dialog for consent to store a cookie
          on the user's device.
        </p>
        <p>
          As for the second question, ChatGPT recommended a bunch of things I
          don't know how to implement yet: locking mechanisms (maintaining a
          separate table to track locks on rows), transactional processing
          (making a change and then saving it, and if an error occurs, it rolls
          back to the original state), optimistic concurrency control (adding a
          timestamp column and making sure it's the correct value before making
          a change), distributed locking (locking mechanisims provided by AWS).
          Turns out I was already doing transactional processing, but I had
          trouble figuring out what to do with the failed commits. My
          architecture is a distributed system, so I figured there has to be
          some sort of design pattern for implementing this in AWS. After some
          googling, I read about automatic retries with AWS Lambda, and decided
          this would be the best approach for now because I don't really get
          much traffic.
        </p>
      </Section>
      <Section>
        <SectionHeader>Initial Architecture</SectionHeader>
        <ClickableFullSizeImage
          src={`${process.env.REACT_APP_IMAGES_BASE_URL}/architecture_diagram_3.jpeg`}
        />
      </Section>
      <Section>
        <SectionHeader>Technical Implementation</SectionHeader>
        <p>
          Based on the above logic, the steps for how I imlemented a "likes"
          system are as follows:
        </p>
        <ol>
          <li>Add a likes column to the articles database</li>
          <li>
            Implement a lambda for increasing or decreasing the number of likes
            on an article in the database
          </li>
          <li>Add an API gateway endpoint to invoke the new lambda</li>
          <li>
            Design and implement a UI for displaying the number of likes on an
            article (using the created endpoint)
          </li>
          <li>
            Store that the user has liked the article in a cookie, and display
            whether the user has liked the article
          </li>
          <li>Allow the user to unlike the post in the UI</li>
        </ol>
      </Section>
      <Section>
        <SubsectionHeader>
          Adding a likes column to the articles database
        </SubsectionHeader>
        <p>
          This was straightforward: I added a line to my model definition for
          the articles table, then ran{" "}
          <Code>
            alembic revision --autogenerate -m "Add likes to article table"
          </Code>{" "}
          to generate a migration file, then made sure it was correct, then ran{" "}
          <Code>alembic upgrade head</Code> to run the migration.
        </p>
        <p>
          By adding the following line to my Article model in sqlalchemy:
          <Code>likes: Mapped[int] = mapped_column(server_default="0")</Code>,
          alembic generated a migration file as follows:
          <SyntaxHighlighter language="python">
            {migrationCode}
          </SyntaxHighlighter>
        </p>
        <p>
          Then, I verified that the likes column was in the table by doing a
          simple select statement:
          <ClickableFullSizeImage
            src={`${process.env.REACT_APP_IMAGES_BASE_URL}/likes_column_in_db.jpeg`}
            alt="likes column added to database, shown through a sql statement"
          />
          And there it is! A likes column for each existing post with the
          default of 0 likes!
        </p>
      </Section>
      <Section>
        <SubsectionHeader>
          Implementing a lambda with connection to a postgres database
        </SubsectionHeader>
        <p>
          The next step is to create a lambda that increases or decreases the
          count of the likes on an article without it going below zero. This was
          simple to accomplish with my existing architecture. Below is the
          source code for the lambda function:
        </p>
        <SyntaxHighlighter language="python">{lambdaCode}</SyntaxHighlighter>
        <p>
          And since I already had a module for deploying a lambda, all I had to
          do was instantiate a new module in terraform for the new function.
        </p>
        <SyntaxHighlighter language="hcl">
          {terraformCodeLambda}
        </SyntaxHighlighter>
        <p>
          And here is a successful execution!
          <ClickableFullSizeImage
            src={`${process.env.REACT_APP_IMAGES_BASE_URL}/successful_like_lambda.jpeg`}
          />
        </p>
      </Section>
      <Section>
        <SubsectionHeader>
          Adding an API gateway endpoint that invokes a lambda function
        </SubsectionHeader>
        <p>
          This was very copy/paste with my existing infrastructure. (Maybe I
          should make a module?) Below is the terraform code:
        </p>
        <SyntaxHighlighter language="hcl">
          {terraformCodeApiGateway}
        </SyntaxHighlighter>
        <p>
          And below is the integration in the AWS console!
          <ClickableFullSizeImage
            src={`${process.env.REACT_APP_IMAGES_BASE_URL}/api_gateway_like_lambda.jpeg`}
          />
        </p>
      </Section>
      <Section>
        <SubsectionHeader>UI</SubsectionHeader>
        <p>
          All I did for the UI was use a package called{" "}
          <Code>react-cookie</Code> that updates the cookie that stores the
          likes. This is wired up to a hook that fires off a POST request to the
          new api endpoint that increases or decreases the likes on a article.
        </p>
        <SyntaxHighlighter language="typescript">
          {reactCode1}
        </SyntaxHighlighter>
      </Section>
    </ArticleContentContainer>
  );
};

export default LikingArticles;
